# chat_room

## epoll简介

使用epoll实现一个简单的聊天服务器对，epoll可以使 I/O 多路复用更加的高效，用到的数据结构包括红黑树和就绪队列，使得 epoll 比 select/poll 更加的高效。当一个事件发生（比如说读文件），epoll 无须遍历整个监听的描述符集，只需要遍历那些被内核 I/O 事件唤醒而加入就绪队列的描述符集合就好了。

## 实现原理

根据 C/S 模型连接建立的过程，可以先让服务端创建一个scoket连接，然后等待客户端的接入（connect），客户端接入后服务端会通过 accept 函数返回一个客户端的scoket文件描述符，然后将该文件描述符加入到一个全局的list变量中，用以保存所有客户端的文件描述符fd。

通过使用 epoll_wait 函数可以统计出就绪事件的数目，通过就绪事件的文件描述符和服务端监听事件的文件描述符进行对比，判断是否是新的事件接入，然后服务器对所有的客户端进行广播。

客户端主要用到了父进程和子进程以及管道相关的知识，子进程负责从屏幕上进行文字的输入，然后将这些文字写入管道中。父进程主要负责两项工作，其一，负责从管道中读出子进程写入的数据，并向服务端发送这些数据，服务端收到这些数据后，再通过广播的方式向其他的客户端发送消息。其二，负责接收服务端发过来的消息，并输出。

以上就是利用epoll实现聊天服务器的基本思路具体的代码实现，我已放在了我的github中。此外如果还想对这个简单的聊天服务器进行扩展的话，还可以从以下几个方面来考虑：线程池、多线程编程、超时重传、确认收包等等。
